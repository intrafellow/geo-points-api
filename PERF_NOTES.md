# Производительность и SQL: что уже хорошо и что можно подтянуть

Короткие заметки по результатам `SQL_CAPTURE.md` и по тому, как сейчас устроены запросы в `PointQuerySet.within_radius()` и `MessageQuerySet.within_radius()`.

## В двух словах

- **Гео‑поиск сделан правильно**: `ST_DWithin` + `geography=True` + радиус задаётся в **км**.
- **PostGIS реально использует GIST‑индекс** по `location` (а не делает `Seq Scan`).
- **Пагинация в DRF почти всегда = 2 запроса**: `COUNT(*)` + основной `SELECT`. Это нормально, пока в ответе есть `count/next/previous`.
- Если хочется ускорить/облегчить — в основном это про **ширину выборки**: не тащить лишние поля из `auth_user` и `geo_points`, и проверить, нет ли повторяющихся “служебных” запросов вокруг SRID.

## Что уже хорошо (и почему)

### Гео‑логика + индекс

В `SQL_CAPTURE.md` видно что-то вроде `ST_DWithin(..., 2000.0)` при `radius=2`. Это значит, что конвертация **км → метры** отрабатывает корректно.

Если смотреть `EXPLAIN`, то картина здоровая:
- сначала идёт **index scan** по `geo_points.location` (через bounding box / `_st_expand`)
- потом фильтрация `st_dwithin(...)` уже проверяет точное расстояние

Именно так и должно быть: индекс быстро отсекает “явно далёких”, а точная проверка делается на небольшом наборе кандидатов.

### `COUNT(*)` при пагинации

В `search_points` и `search_messages` лишний `COUNT(*)` не “внезапный тормоз”, а часть контракта: без него нельзя вернуть поле `count`. Убрать его можно только если менять формат ответа.

## Что можно улучшить (не трогая контракты API)

### Не вытаскивать лишнее из `auth_user` на каждом запросе

В `SQL_CAPTURE.md` обычно видно, что при JWT‑аутентификации Django подгружает пользователя и достаёт много колонок из `auth_user` (включая то, что вам в API вообще не нужно).

Идея простая: если это становится заметно по профилю, можно грузить пользователя “узко” (через `.only(...)`) — например, оставить минимум вроде `id`, `username`, `is_active`, `is_staff`, `is_superuser`.

Семантика и коды ответов не меняются, а данных гоняется меньше.

### `search_messages`: не тянуть поля точки

Для ответа сообщений точка в виде объекта не нужна: сериализуется только `point_id`, а по автору нужен только `author.username`.

Поэтому хорошая цель — чтобы запрос:
- делал `select_related("author")`
- выбирал через `.only(...)` только реально нужные поля сообщений и `author__username`
- при этом geo‑фильтр работал через join на `geo_points`, но без “толстой” выборки `geo_points.*`

Это уменьшает нагрузку на сеть/память и в целом делает запросы “стройнее”.

### `create_message`: проверка существования точки по `id`

При создании сообщения достаточно проверить существование `Point` по `id`, не вытаскивая гео‑поле и другие тяжёлые колонки. Текущая идея “читать только id” — правильная.

### Запрос к `spatial_ref_sys`

В capture иногда всплывает запрос к `spatial_ref_sys` по `srid=4326`. Часто это одноразовый прогрев/кэш и дальше не повторяется.

Если же он начинает вылезать стабильно на каждом запросе — тогда стоит копать настройки/версии GIS‑стека (GDAL/GEOS) и кэширование SpatialReference. Но обычно это не главное узкое место по сравнению с самой geo‑фильтрацией.